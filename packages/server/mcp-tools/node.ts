// @ts-nocheck
import { Context } from 'cordis';
import { Logger } from '@ejunz/utils';
import {
    zigbeeListDevicesTool,
    callZigbeeListDevicesTool,
    zigbeeGetDeviceStatusTool,
    callZigbeeGetDeviceStatusTool,
    zigbeeControlTool,
    callZigbeeControlTool,
} from './nodeZigbee';

const logger = new Logger('node-mcp');

export interface NodeToolDefinition {
    name: string;
    description: string;
    inputSchema: any;
    metadata?: Record<string, any>;
}

export interface NodeToolRegistryEntry {
    tool: NodeToolDefinition;
    handler: (ctx: Context, args: any) => Promise<any>;
    metadata?: Record<string, any>;
    autoGenerated?: boolean;
}

const baseEntries: Array<[string, NodeToolRegistryEntry]> = [
    [
        'zigbee_list_devices',
        {
            tool: zigbeeListDevicesTool,
            handler: callZigbeeListDevicesTool,
            metadata: { category: 'node-core', autoGenerated: false },
        },
    ],
    [
        'zigbee_get_device_status',
        {
            tool: zigbeeGetDeviceStatusTool,
            handler: callZigbeeGetDeviceStatusTool,
            metadata: { category: 'node-core', autoGenerated: false },
        },
    ],
    [
        'zigbee_control_device',
        {
            tool: zigbeeControlTool,
            handler: callZigbeeControlTool,
            metadata: { category: 'node-core', autoGenerated: false },
        },
    ],
];

const nodeToolRegistry = new Map<string, NodeToolRegistryEntry>(baseEntries);
const dynamicToolNames = new Set<string>();

// 获取所有 Node 工具列表
export function listNodeTools(includeMetadata = false): NodeToolDefinition[] {
    return Array.from(nodeToolRegistry.values()).map((entry) => {
        if (!includeMetadata) return entry.tool;
        return {
            ...entry.tool,
            metadata: {
                ...(entry.tool.metadata || {}),
                ...(entry.metadata || {}),
            },
        };
    });
}

export function getNodeToolEntry(name: string): NodeToolRegistryEntry | undefined {
    return nodeToolRegistry.get(name);
}

export function setDynamicNodeTools(entries: NodeToolRegistryEntry[]): void {
    // 清除旧的动态工具
    for (const toolName of dynamicToolNames) {
        nodeToolRegistry.delete(toolName);
    }
    dynamicToolNames.clear();

    // 注册新的动态工具
    for (const entry of entries) {
        const toolName = entry.tool.name;
        if (!toolName) continue;
        nodeToolRegistry.set(toolName, {
            ...entry,
            metadata: {
                ...(entry.metadata || {}),
                autoGenerated: true,
            },
            autoGenerated: true,
        });
        dynamicToolNames.add(toolName);
    }
}

export function clearDynamicNodeTools(): void {
    for (const toolName of dynamicToolNames) {
        nodeToolRegistry.delete(toolName);
    }
    dynamicToolNames.clear();
}

// 调用 Node 工具
export async function callNodeTool(ctx: Context, request: { name: string; arguments: any }): Promise<any> {
    const { name, arguments: args } = request;
    const startTime = Date.now();
    
    // 记录工具调用开始
    logger.info('[MCP工具调用] %s 参数: %o', name, args);
    
    const entry = nodeToolRegistry.get(name);
    if (!entry) {
        logger.error('[MCP工具调用] 未知工具: %s', name);
        throw new Error(`Unknown node tool: ${name}`);
    }
    
    try {
        const result = await entry.handler(ctx, args);
        const duration = Date.now() - startTime;
        
        // 记录工具调用成功
        const resultPreview = typeof result === 'object' 
            ? JSON.stringify(result).substring(0, 200) 
            : String(result).substring(0, 200);
        logger.success('[MCP工具调用] %s 成功 (耗时: %dms) 结果: %s', name, duration, resultPreview);
        
        return result;
    } catch (error) {
        const duration = Date.now() - startTime;
        logger.error('[MCP工具调用] %s 失败 (耗时: %dms) 错误: %s', name, duration, (error as Error).message);
        throw error;
    }
}

